#+title: Mini Grep
#+PROPERTY: header-args :noweb yes
#+auto_tangle:y

#+begin_quote
 You have been given a crate, mini_grep, which prints the first command-line argument.

Your task is to modify mini_grep/src/main.rs, such that it reads lines on standard input, printing each line back out if and only if the input line contains the command-line argument.
#+end_quote

#+begin_src rust :tangle main.rs
use std::io;

fn main() {
    <<pattern-string-declaration>>
    <<pattern-reference-declaration>>
    <<input-string-declaration>>
    <<main-loop>>
}
#+end_src

* Read the pattern string
Use the first command-line argument as the pattern to look for.
#+name: pattern-string-declaration
#+begin_src rust
let pattern_string: String = std::env::args()
    .nth(1)
    .expect("missing required command-line argument: <pattern>");
#+end_src

For convenience, create a reference to the pattern string.
#+name: pattern-reference-declaration
#+begin_src rust
let pattern: &String = &pattern_string;
#+end_src

* Read the input
Begin by declaring a mutable string to store the input from stdin.
#+name: input-string-declaration
#+begin_src rust
let mut input: String = String::new();
#+end_src

The main part of the code will be a loop that constantly reads in strings from stdin and stores it into the variable created above, =input=. The logic for it is as follows:

1. If there are no issues in reading the string:
   a. Check if =input= is an empty string. If so, break out of the loop.
   b. Check if =input= contains =pattern=. If so, print it out.
   c. Clear the content of =input=.
2. If there are issues in reading the string, print an error message.

The =loop= keyword can be used to create an indefinite loop that will run until explicitly broken out of.
#+name:main-loop
#+begin_src rust
loop {
    <<read-line-and-check>>
}
#+end_src

With that, the =read_line= function can be used to handle the input string and pattern-matching logic.
#+name:read-line-and-check
#+begin_src rust
match io::stdin().read_line(&mut input) {
    Ok(_n) => {
        <<check-empty>>
        <<check-pattern>>
        <<clear-string>>
    }
    Err(error) => println!("error: {error}"),
}
#+end_src

If =read_line= successfully read a string into =input=, begin by checking if the string is empty and break out if so.
#+name: check-empty
#+begin_src rust
if input.is_empty() {
    break;
}
#+end_src

Otherwise, check if the pattern string is contained inside the input string. If so, strip the input string of any newline (=\n=) characters and print it out.
#+name: check-pattern
#+begin_src rust
if input.contains(pattern) {
    println!("{}", input.replace('\n', ""));
}
#+end_src

Lastly, clear the input string to reset for the next iteration.
#+name: clear-string
#+begin_src rust
input.clear();
#+end_src
