#+title: Repeat
#+PROPERTY: header-args :noweb yes
#+auto_tangle:y

#+begin_src rust :tangle main.rs
use std::io;

fn main() {
    <<input-declaration>>
    <<read-line-and-repeat>>
}
#+end_src

* Declare input variable
Variables are immutable by default in Rust. To make it mutable, it is necessary to declare it as such.

#+name: input-declaration
#+begin_src rust
let mut input = String::new();
#+end_src

* Read the line
The function =io::stdin()= has the following signature:
#+begin_src rust
pub fn stdin() -> Stdin
#+end_src

In other words, it is simply a constructor for an instance of =Stdin=,  a handle to the standard input stream of a process. It contains the =read_line= function, which has the following signature:
#+begin_src rust
pub fn read_line(&self, buf: &mut String) -> Result<usize>
#+end_src

- =pub= is known as a /visibility modifier/, which indicates that the function can be accessed from other modules.
- =fn= indicates the declaration of a function.
- =&self= is an immutable reference without a type definition.
- =buf= is a mutable reference (=&mut=) to a =String=.
- The function outputs a =Result= enum instance containing either:
  - a successful result (the number of bytes read), represented by =Ok(value)=, or
  - an error, represented by =Error(error_info)=.

With that, a pattern-matching expression can be constructed to cover the successful and unsuccessful case:

#+name:read-line-and-repeat
#+begin_src rust
match io::stdin().read_line(&mut input) {
    Ok(_n) => {
        println!("{input}");
    }
    Err(error) => println!("error: {error}"),
}
#+end_src
